<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discrete Diffusion Text Generation - Live Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Monaco', 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #fff;
        }

        .container {
            max-width: 900px;
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            color: #333;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #667eea;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            color: #666;
            font-size: 0.9em;
        }

        .info-box {
            background: #f0f4ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-bottom: 25px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
        }

        .stat-label {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #667eea;
        }

        .output-container {
            background: #1e1e1e;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
            min-height: 400px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            color: #d4d4d4;
            position: relative;
            overflow-y: auto;
            max-height: 600px;
        }

        .step-indicator {
            position: sticky;
            top: 0;
            background: #2d2d2d;
            padding: 10px;
            margin: -25px -25px 15px -25px;
            border-radius: 10px 10px 0 0;
            border-bottom: 2px solid #667eea;
            z-index: 10;
        }

        .step-label {
            font-weight: bold;
            color: #667eea;
        }

        .noise-level {
            font-size: 0.85em;
            color: #888;
            margin-left: 15px;
        }

        .text-output {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .char {
            display: inline-block;
            transition: all 0.3s ease;
        }

        .char.changed {
            background-color: rgba(102, 126, 234, 0.3);
            animation: highlight 0.6s ease;
        }

        @keyframes highlight {
            0%, 100% { background-color: rgba(102, 126, 234, 0.3); }
            50% { background-color: rgba(102, 126, 234, 0.6); }
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 25px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .footer {
            text-align: center;
            margin-top: 20px;
            font-size: 0.85em;
            color: #666;
        }

        .footer a {
            color: #667eea;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        .seed-info {
            font-size: 0.85em;
            color: #888;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåä Discrete Diffusion Text Generation</h1>
        <p class="subtitle">Character-level text generation through iterative denoising</p>

        <div class="info-box">
            <strong>How it works:</strong> This demo implements discrete diffusion for text generation.
            Starting from random noise (random characters), the model iteratively denoises the text over multiple steps,
            gradually revealing coherent text. The seed changes every minute based on system time.
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Current Seed</div>
                <div class="stat-value" id="currentSeed">0</div>
                <div class="seed-info">Updates every minute</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Sequence Length</div>
                <div class="stat-value" id="seqLength">256</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Denoising Steps</div>
                <div class="stat-value" id="totalSteps">64</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Vocabulary Size</div>
                <div class="stat-value" id="vocabSize">65</div>
            </div>
        </div>

        <div class="controls">
            <button id="startBtn" onclick="startGeneration()">‚ñ∂ Start Generation</button>
            <button id="pauseBtn" onclick="pauseGeneration()" disabled>‚è∏ Pause</button>
            <button id="resetBtn" onclick="resetGeneration()">üîÑ Reset</button>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressBar"></div>
        </div>

        <div class="output-container">
            <div class="step-indicator">
                <span class="step-label">Status:</span>
                <span id="statusText">Ready to generate</span>
                <span class="noise-level" id="noiseLevel"></span>
            </div>
            <div class="text-output" id="textOutput">
                Click "Start Generation" to begin the denoising process...
            </div>
        </div>

        <div class="footer">
            <p>
                Based on <a href="https://arxiv.org/abs/2310.16834" target="_blank">Discrete Diffusion Modeling by Estimating the Ratios of the Data Distribution</a>
            </p>
            <p style="margin-top: 10px;">
                <a href="https://github.com/ash80/diffusion-gpt" target="_blank">View source on GitHub</a>
            </p>
        </div>
    </div>

    <script>
        // Shakespeare-inspired character-level vocabulary
        const vocab = "\n !\"&'(),-.0123456789:;?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        const vocabSize = vocab.length;
        const charToIdx = {};
        const idxToChar = {};

        vocab.split('').forEach((char, idx) => {
            charToIdx[char] = idx;
            idxToChar[idx] = char;
        });

        // Configuration
        const config = {
            seqLength: 256,
            steps: 64,
            sigmaMin: 0.0001,
            sigmaMax: 20.0,
            delayMs: 100  // delay between denoising steps for visualization
        };

        // State
        let currentSequence = [];
        let currentStep = 0;
        let isPaused = false;
        let isRunning = false;
        let currentSeed = 0;
        let rng = null;

        // Simple seeded random number generator (Mulberry32)
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }

            random() {
                let t = this.seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            randint(min, max) {
                return Math.floor(this.random() * (max - min)) + min;
            }

            choice(arr) {
                return arr[this.randint(0, arr.length)];
            }
        }

        // Get seed from current minute
        function getCurrentMinuteSeed() {
            const now = new Date();
            // Seed changes every minute
            return Math.floor(now.getTime() / 60000);
        }

        // Update seed display
        function updateSeedDisplay() {
            currentSeed = getCurrentMinuteSeed();
            document.getElementById('currentSeed').textContent = currentSeed;
        }

        // Initialize RNG with current seed
        function initializeRNG() {
            currentSeed = getCurrentMinuteSeed();
            rng = new SeededRandom(currentSeed);
            updateSeedDisplay();
        }

        // Geometric noise schedule
        function geometricNoise(t) {
            const { sigmaMin, sigmaMax } = config;
            // bar_sigma(t) = sigma_min^(1-t) * sigma_max^t
            const barSigma = Math.pow(sigmaMin, 1 - t) * Math.pow(sigmaMax, t);
            return barSigma;
        }

        // Character bigram transition probabilities (simplified scoring model)
        // In a real model, this would be learned. Here we use basic English statistics.
        function getCharTransitionScore(fromIdx, toIdx) {
            const fromChar = idxToChar[fromIdx];
            const toChar = idxToChar[toIdx];

            // Simple heuristic scores based on English language patterns
            let score = 1.0;

            // Vowels after consonants are more likely
            const vowels = 'aeiouAEIOU';
            const consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ';

            if (consonants.includes(fromChar) && vowels.includes(toChar)) {
                score *= 2.0;
            }

            // Common bigrams
            const commonBigrams = ['th', 'he', 'in', 'er', 'an', 're', 'on', 'at', 'en', 'nd'];
            const bigram = fromChar + toChar;
            if (commonBigrams.includes(bigram.toLowerCase())) {
                score *= 3.0;
            }

            // Spaces after punctuation
            if ('.,!?;:'.includes(fromChar) && toChar === ' ') {
                score *= 2.5;
            }

            // Lowercase after space
            if (fromChar === ' ' && toChar >= 'a' && toChar <= 'z') {
                score *= 1.8;
            }

            // Capital after period/newline
            if (('.\n'.includes(fromChar) || fromChar === '!') && toChar >= 'A' && toChar <= 'Z') {
                score *= 2.0;
            }

            // Penalize repeated characters (except common ones)
            if (fromChar === toChar && !'leotsn '.includes(fromChar)) {
                score *= 0.3;
            }

            return score;
        }

        // Compute score for entire vocabulary given current sequence
        function computeScores(sequence, position, sigma) {
            const scores = new Array(vocabSize).fill(0);
            const currentChar = sequence[position];

            // Look at context (previous and next characters)
            const prevChar = position > 0 ? sequence[position - 1] : -1;
            const nextChar = position < sequence.length - 1 ? sequence[position + 1] : -1;

            for (let i = 0; i < vocabSize; i++) {
                let score = 1.0;

                // Score based on previous character
                if (prevChar >= 0) {
                    score *= getCharTransitionScore(prevChar, i);
                }

                // Score based on next character
                if (nextChar >= 0) {
                    score *= getCharTransitionScore(i, nextChar);
                }

                // Add some randomness influenced by sigma (noise level)
                const randomFactor = 1.0 + (rng.random() - 0.5) * sigma / 10;
                score *= randomFactor;

                scores[i] = score;
            }

            // Set current token score to 0 (as per the model)
            scores[currentChar] = 0;

            return scores;
        }

        // Sample from categorical distribution
        function sampleCategorical(probs) {
            const sum = probs.reduce((a, b) => a + b, 0);
            const normalized = probs.map(p => p / sum);

            const r = rng.random();
            let cumsum = 0;
            for (let i = 0; i < normalized.length; i++) {
                cumsum += normalized[i];
                if (r < cumsum) {
                    return i;
                }
            }
            return normalized.length - 1;
        }

        // Transition kernel
        function computeTransition(currentIdx, deltaSigma) {
            const trans = new Array(vocabSize).fill(0);
            const baseProb = (1 - Math.exp(-deltaSigma)) / vocabSize;

            for (let i = 0; i < vocabSize; i++) {
                trans[i] = baseProb;
            }
            trans[currentIdx] = 0;

            // Diagonal fill to ensure sum to 1
            const diagFill = 1 - trans.reduce((a, b) => a + b, 0);
            trans[currentIdx] = diagFill;

            return trans;
        }

        // Staggered score correction
        function staggeredScore(score, deltaSigma) {
            const expFactor = Math.exp(-deltaSigma);
            const scoreSum = score.reduce((a, b) => a + b, 0);
            const correction = ((expFactor - 1) / (vocabSize * expFactor)) * scoreSum;

            return score.map(s => correction + s / expFactor);
        }

        // Initialize sequence with random characters
        function initializeSequence() {
            initializeRNG();
            currentSequence = [];
            for (let i = 0; i < config.seqLength; i++) {
                currentSequence.push(rng.randint(0, vocabSize));
            }
            currentStep = 0;
            updateDisplay();
        }

        // Perform one denoising step
        function denoisingStep() {
            const eps = 1e-5;
            const t = 1 - (currentStep / config.steps) * (1 - eps);
            const tNext = 1 - ((currentStep + 1) / config.steps) * (1 - eps);

            const currSigma = geometricNoise(t);
            const nextSigma = currentStep < config.steps - 1 ? geometricNoise(tNext) : 0;
            const deltaSigma = currSigma - nextSigma;

            // Track which characters changed for animation
            const prevSequence = [...currentSequence];

            // Denoise each position
            for (let pos = 0; pos < currentSequence.length; pos++) {
                const currentIdx = currentSequence[pos];

                // Compute scores from model
                const scores = computeScores(currentSequence, pos, currSigma);

                // Apply staggered score
                const stagScore = staggeredScore(scores, deltaSigma);

                // Get transition probabilities
                const trans = computeTransition(currentIdx, deltaSigma);

                // Combine score and transition
                const probs = stagScore.map((s, i) => s * trans[i]);

                // Sample new character
                currentSequence[pos] = sampleCategorical(probs);
            }

            currentStep++;
            updateDisplay(prevSequence);

            return currentStep < config.steps;
        }

        // Update display
        function updateDisplay(prevSequence = null) {
            const text = currentSequence.map(idx => idxToChar[idx]).join('');
            const outputDiv = document.getElementById('textOutput');

            if (prevSequence) {
                // Highlight changed characters
                let html = '';
                for (let i = 0; i < currentSequence.length; i++) {
                    const char = idxToChar[currentSequence[i]];
                    const displayChar = char === '\n' ? '‚Üµ\n' : char;
                    const changed = currentSequence[i] !== prevSequence[i];
                    html += `<span class="char ${changed ? 'changed' : ''}">${displayChar}</span>`;
                }
                outputDiv.innerHTML = html;
            } else {
                outputDiv.textContent = text.replace(/\n/g, '‚Üµ\n');
            }

            // Update stats
            const progress = (currentStep / config.steps) * 100;
            document.getElementById('progressBar').style.width = progress + '%';

            const t = 1 - (currentStep / config.steps);
            const sigma = geometricNoise(t);

            document.getElementById('statusText').textContent =
                `Step ${currentStep}/${config.steps}`;
            document.getElementById('noiseLevel').textContent =
                `œÉ = ${sigma.toFixed(4)}`;
        }

        // Animation loop
        async function runGeneration() {
            if (isPaused || !isRunning) return;

            const continueRunning = denoisingStep();

            if (continueRunning && isRunning && !isPaused) {
                setTimeout(runGeneration, config.delayMs);
            } else {
                isRunning = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;

                if (currentStep >= config.steps) {
                    document.getElementById('statusText').textContent =
                        'Generation complete!';
                }
            }
        }

        // Control functions
        function startGeneration() {
            if (currentStep === 0) {
                initializeSequence();
            }

            isRunning = true;
            isPaused = false;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;

            runGeneration();
        }

        function pauseGeneration() {
            isPaused = true;
            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('statusText').textContent = 'Paused';
        }

        function resetGeneration() {
            isPaused = false;
            isRunning = false;
            currentStep = 0;

            initializeSequence();

            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('statusText').textContent = 'Ready to generate';
            document.getElementById('noiseLevel').textContent = '';
        }

        // Update display on load
        document.getElementById('seqLength').textContent = config.seqLength;
        document.getElementById('totalSteps').textContent = config.steps;
        document.getElementById('vocabSize').textContent = vocabSize;
        updateSeedDisplay();

        // Update seed display every second
        setInterval(updateSeedDisplay, 1000);

        // Initialize display
        initializeRNG();
    </script>
</body>
</html>
