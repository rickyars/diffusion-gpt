<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug: ONNX Inference Diagnostics</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    <style>
        body {
            font-family: 'Monaco', 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #4fc3f7;
            border-bottom: 2px solid #4fc3f7;
            padding-bottom: 10px;
        }

        h2 {
            color: #81c784;
            margin-top: 30px;
        }

        .section {
            background: #2d2d2d;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid #4fc3f7;
        }

        .config-section {
            background: #3a3a1a;
            border-left-color: #ffc107;
        }

        .debug-output {
            background: #1a1a1a;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 0.9em;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #444;
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 2px solid #666;
            padding-left: 10px;
        }

        .log-info { color: #4fc3f7; }
        .log-success { color: #81c784; }
        .log-warning { color: #ffb74d; }
        .log-error { color: #e57373; }
        .log-debug { color: #ba68c8; }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .stat-box {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #444;
        }

        .stat-label {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #4fc3f7;
        }

        button {
            background: #4fc3f7;
            color: #1e1e1e;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }

        button:hover:not(:disabled) {
            background: #29b6f6;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            color: #888;
        }

        input[type="text"] {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #d4d4d4;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
            margin: 5px 0;
        }

        .text-preview {
            background: #1a1a1a;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            border: 1px solid #444;
            white-space: pre-wrap;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
            max-height: 300px;
            overflow-y: auto;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .error-box {
            background: #3a1a1a;
            border: 2px solid #e57373;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success-box {
            background: #1a3a1a;
            border: 2px solid #81c784;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .controls {
            margin: 20px 0;
        }

        .checkbox-group {
            margin: 15px 0;
        }

        .checkbox-item {
            display: inline-flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 10px;
        }

        .checkbox-item input {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <h1>üîç ONNX Inference Debugging Tool</h1>
    <p style="color: #888;">Comprehensive diagnostics for discrete diffusion model inference in browser</p>

    <div class="section config-section">
        <h2>‚öôÔ∏è Configuration</h2>
        <label>Model URL:</label>
        <input type="text" id="modelUrl" value="./demo/model.onnx">
        <label>Vocabulary URL:</label>
        <input type="text" id="vocabUrl" value="./demo/vocab.json">
        <label>Metadata URL:</label>
        <input type="text" id="metadataUrl" value="./demo/metadata.json">

        <div class="checkbox-group">
            <div class="checkbox-item">
                <input type="checkbox" id="verboseLogging" checked>
                <label for="verboseLogging">Verbose logging</label>
            </div>
            <div class="checkbox-item">
                <input type="checkbox" id="logDistributions" checked>
                <label for="logDistributions">Log distribution stats</label>
            </div>
            <div class="checkbox-item">
                <input type="checkbox" id="logEachPosition">
                <label for="logEachPosition">Log each position (slower)</label>
            </div>
        </div>

        <div class="controls">
            <button onclick="loadModel()">üì• Load Model</button>
            <button id="testInferenceBtn" onclick="testInference()" disabled>üß™ Test Single Inference</button>
            <button id="testStepBtn" onclick="testDenoisingStep()" disabled>üîÑ Test One Denoising Step</button>
            <button id="runFullBtn" onclick="runFullGeneration()" disabled>‚ñ∂ Run Full Generation</button>
            <button onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
        </div>
    </div>

    <div class="section">
        <h2>üìä Model Status</h2>
        <div class="stat-grid">
            <div class="stat-box">
                <div class="stat-label">Model Status</div>
                <div class="stat-value" id="modelStatus">Not Loaded</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Vocab Size</div>
                <div class="stat-value" id="vocabSize">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Sequence Length</div>
                <div class="stat-value" id="seqLength">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Current Step</div>
                <div class="stat-value" id="currentStepDisplay">-</div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>üìù Debug Logs</h2>
        <div class="debug-output" id="debugLogs">
            Waiting for model load...
        </div>
    </div>

    <div class="section">
        <h2>üìÑ Generated Text Preview</h2>
        <div class="text-preview" id="textPreview">
            No generation yet...
        </div>
    </div>

    <div class="section">
        <h2>üìà Inference Statistics</h2>
        <div class="debug-output" id="statsOutput">
            Run inference to see statistics...
        </div>
    </div>

    <script>
        // Global state
        let session = null;
        let vocab = null;
        let metadata = null;
        let currentSequence = [];
        let currentStep = 0;
        let rng = null;

        // Configuration
        const config = {
            steps: 64,
            sigmaMin: 0.0001,
            sigmaMax: 20.0
        };

        // Logging utilities
        function log(message, type = 'info') {
            const logsDiv = document.getElementById('debugLogs');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logsDiv.appendChild(entry);
            logsDiv.scrollTop = logsDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function clearLogs() {
            document.getElementById('debugLogs').innerHTML = '';
            document.getElementById('statsOutput').innerHTML = '';
        }

        function logStats(title, data) {
            const statsDiv = document.getElementById('statsOutput');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<strong>${title}</strong><br>${JSON.stringify(data, null, 2)}`;
            statsDiv.appendChild(entry);
            statsDiv.scrollTop = statsDiv.scrollHeight;
        }

        // Seeded RNG
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }

            random() {
                let t = this.seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            randint(min, max) {
                return Math.floor(this.random() * (max - min)) + min;
            }
        }

        // Load model
        async function loadModel() {
            const modelUrl = document.getElementById('modelUrl').value;
            const vocabUrl = document.getElementById('vocabUrl').value;
            const metadataUrl = document.getElementById('metadataUrl').value;

            try {
                log('Loading model files...', 'info');

                // Load metadata
                log(`Fetching metadata: ${metadataUrl}`, 'debug');
                const metadataResponse = await fetch(metadataUrl);
                if (!metadataResponse.ok) throw new Error(`Failed to load metadata: ${metadataResponse.statusText}`);
                metadata = await metadataResponse.json();
                log(`Metadata loaded: ${JSON.stringify(metadata)}`, 'success');

                // Load vocabulary
                log(`Fetching vocabulary: ${vocabUrl}`, 'debug');
                const vocabResponse = await fetch(vocabUrl);
                if (!vocabResponse.ok) throw new Error(`Failed to load vocabulary: ${vocabResponse.statusText}`);
                vocab = await vocabResponse.json();
                log(`Vocabulary loaded: ${Object.keys(vocab.itos).length} characters`, 'success');

                // Show vocab sample
                const vocabSample = Object.entries(vocab.itos).slice(0, 10).map(([k, v]) => `${k}:${JSON.stringify(v)}`).join(', ');
                log(`Vocab sample: ${vocabSample}`, 'debug');

                // Load ONNX model
                log(`Fetching ONNX model: ${modelUrl}`, 'debug');
                session = await ort.InferenceSession.create(modelUrl);
                log('ONNX session created successfully', 'success');

                // Show model inputs/outputs
                const inputs = session.inputNames;
                const outputs = session.outputNames;
                log(`Model inputs: ${inputs.join(', ')}`, 'info');
                log(`Model outputs: ${outputs.join(', ')}`, 'info');

                // Update UI
                document.getElementById('modelStatus').textContent = '‚úì Loaded';
                document.getElementById('vocabSize').textContent = metadata.vocab_size;
                document.getElementById('seqLength').textContent = metadata.block_size;
                document.getElementById('testInferenceBtn').disabled = false;
                document.getElementById('testStepBtn').disabled = false;
                document.getElementById('runFullBtn').disabled = false;

                // Initialize RNG
                const seed = Math.floor(Date.now() / 60000);
                rng = new SeededRandom(seed);
                log(`Initialized RNG with seed: ${seed}`, 'info');

                log('‚úÖ All components loaded successfully!', 'success');

            } catch (error) {
                log(`‚ùå Error loading model: ${error.message}`, 'error');
                console.error('Full error:', error);
                document.getElementById('modelStatus').textContent = '‚úó Error';
            }
        }

        // Test single inference
        async function testInference() {
            try {
                log('=== TESTING SINGLE INFERENCE ===', 'info');

                // Create random input
                const seqLen = metadata.block_size;
                const vocabSize = metadata.vocab_size;
                const inputIds = [];
                for (let i = 0; i < seqLen; i++) {
                    inputIds.push(rng.randint(0, vocabSize));
                }
                const sigma = 10.0;

                log(`Input shape: [1, ${inputIds.length}]`, 'debug');
                log(`Input sample (first 10): [${inputIds.slice(0, 10).join(', ')}]`, 'debug');
                log(`Sigma: ${sigma}`, 'debug');

                // Create tensors
                const inputIdsTensor = new ort.Tensor('int64', BigInt64Array.from(inputIds.map(x => BigInt(x))), [1, inputIds.length]);
                const sigmaTensor = new ort.Tensor('float32', new Float32Array([sigma]), [1]);

                log('Tensors created, running inference...', 'debug');

                // Run inference
                const startTime = performance.now();
                const results = await session.run({
                    'input_ids': inputIdsTensor,
                    'sigma': sigmaTensor
                });
                const endTime = performance.now();

                log(`Inference completed in ${(endTime - startTime).toFixed(2)}ms`, 'success');

                // Extract logits
                const logits = results.logits.data;
                const logitsShape = results.logits.dims;
                log(`Output shape: [${logitsShape.join(', ')}]`, 'info');

                // Compute statistics
                const logitsArray = Array.from(logits);
                const min = Math.min(...logitsArray);
                const max = Math.max(...logitsArray);
                const mean = logitsArray.reduce((a, b) => a + b, 0) / logitsArray.length;
                const std = Math.sqrt(logitsArray.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / logitsArray.length);

                logStats('Logits Statistics', {
                    shape: logitsShape,
                    min: min.toFixed(4),
                    max: max.toFixed(4),
                    mean: mean.toFixed(4),
                    std: std.toFixed(4),
                    numNaN: logitsArray.filter(x => isNaN(x)).length,
                    numInf: logitsArray.filter(x => !isFinite(x)).length
                });

                // Check for first position
                const firstPosLogits = logitsArray.slice(0, vocabSize);
                const firstPosMin = Math.min(...firstPosLogits);
                const firstPosMax = Math.max(...firstPosLogits);
                const firstPosMean = firstPosLogits.reduce((a, b) => a + b, 0) / firstPosLogits.length;

                logStats('First Position Logits', {
                    min: firstPosMin.toFixed(4),
                    max: firstPosMax.toFixed(4),
                    mean: firstPosMean.toFixed(4),
                    sample: firstPosLogits.slice(0, 10).map(x => x.toFixed(4))
                });

                // Convert to scores (exp)
                const scores = firstPosLogits.map(x => Math.exp(x));
                const scoresSum = scores.reduce((a, b) => a + b, 0);
                const scoresMin = Math.min(...scores);
                const scoresMax = Math.max(...scores);

                logStats('First Position Scores (exp)', {
                    min: scoresMin.toExponential(4),
                    max: scoresMax.toExponential(4),
                    sum: scoresSum.toExponential(4),
                    sample: scores.slice(0, 10).map(x => x.toExponential(4))
                });

                // Check if output makes sense
                if (isNaN(min) || isNaN(max) || !isFinite(min) || !isFinite(max)) {
                    log('‚ö†Ô∏è WARNING: Output contains NaN or Inf values!', 'error');
                } else if (Math.abs(mean) > 100) {
                    log('‚ö†Ô∏è WARNING: Logits have unusually large magnitude!', 'warning');
                } else {
                    log('‚úÖ Output looks reasonable', 'success');
                }

            } catch (error) {
                log(`‚ùå Error in inference: ${error.message}`, 'error');
                console.error('Full error:', error);
            }
        }

        // Geometric noise schedule
        function geometricNoise(t) {
            const { sigmaMin, sigmaMax } = config;
            const barSigma = Math.pow(sigmaMin, 1 - t) * Math.pow(sigmaMax, t);
            return barSigma;
        }

        // Sample from categorical distribution
        function sampleCategorical(probs) {
            const sum = probs.reduce((a, b) => a + b, 0);
            if (sum === 0 || !isFinite(sum)) {
                log('‚ö†Ô∏è WARNING: Invalid probability sum, using uniform sampling', 'warning');
                return rng.randint(0, probs.length);
            }
            const normalized = probs.map(p => p / sum);

            const r = rng.random();
            let cumsum = 0;
            for (let i = 0; i < normalized.length; i++) {
                cumsum += normalized[i];
                if (r < cumsum) {
                    return i;
                }
            }
            return normalized.length - 1;
        }

        // Transition kernel
        function computeTransition(currentIdx, deltaSigma, vocabSize) {
            const trans = new Array(vocabSize).fill(0);
            const baseProb = (1 - Math.exp(-deltaSigma)) / vocabSize;

            for (let i = 0; i < vocabSize; i++) {
                trans[i] = baseProb;
            }
            trans[currentIdx] = 0;

            const diagFill = 1 - trans.reduce((a, b) => a + b, 0);
            trans[currentIdx] = diagFill;

            return trans;
        }

        // Staggered score correction
        function staggeredScore(score, deltaSigma, vocabSize) {
            const expFactor = Math.exp(-deltaSigma);
            const scoreSum = score.reduce((a, b) => a + b, 0);
            const correction = ((expFactor - 1) / (vocabSize * expFactor)) * scoreSum;

            return score.map(s => correction + s / expFactor);
        }

        // Test one denoising step
        async function testDenoisingStep() {
            try {
                log('=== TESTING ONE DENOISING STEP ===', 'info');

                // Initialize sequence if needed
                if (currentSequence.length === 0) {
                    const seqLen = metadata.block_size;
                    const vocabSize = metadata.vocab_size;
                    currentSequence = [];
                    for (let i = 0; i < seqLen; i++) {
                        currentSequence.push(rng.randint(0, vocabSize));
                    }
                    currentStep = 0;
                    log(`Initialized random sequence of length ${seqLen}`, 'info');
                }

                const eps = 1e-5;
                const totalSteps = config.steps;

                // Calculate timestep
                const t = 1 - (currentStep / totalSteps) * (1 - eps);
                const tNext = 1 - ((currentStep + 1) / totalSteps) * (1 - eps);

                const currSigma = geometricNoise(t);
                const nextSigma = geometricNoise(tNext);
                const deltaSigma = currSigma - nextSigma;

                log(`Step ${currentStep}/${totalSteps}`, 'info');
                logStats('Timestep Parameters', {
                    t: t.toFixed(6),
                    tNext: tNext.toFixed(6),
                    currSigma: currSigma.toFixed(6),
                    nextSigma: nextSigma.toFixed(6),
                    deltaSigma: deltaSigma.toFixed(6)
                });

                // Show current text
                const currentText = currentSequence.map(idx => vocab.itos[idx.toString()]).join('');
                log(`Current text (first 100 chars): ${currentText.substring(0, 100)}`, 'debug');

                // Run model inference
                log('Running model inference...', 'debug');
                const inputIdsTensor = new ort.Tensor('int64', BigInt64Array.from(currentSequence.map(x => BigInt(x))), [1, currentSequence.length]);
                const sigmaTensor = new ort.Tensor('float32', new Float32Array([currSigma]), [1]);

                const results = await session.run({
                    'input_ids': inputIdsTensor,
                    'sigma': sigmaTensor
                });

                const logits = results.logits.data;
                const vocabSize = metadata.vocab_size;

                // Convert to scores (exp)
                log('Converting logits to scores...', 'debug');
                const scores = [];
                for (let i = 0; i < currentSequence.length; i++) {
                    const row = [];
                    for (let j = 0; j < vocabSize; j++) {
                        row.push(Math.exp(logits[i * vocabSize + j]));
                    }
                    scores.push(row);
                }

                // Process first position in detail
                const pos = 0;
                const currentIdx = currentSequence[pos];
                const score = scores[pos];

                logStats('Position 0 Scores', {
                    currentToken: currentIdx,
                    currentChar: JSON.stringify(vocab.itos[currentIdx.toString()]),
                    scoreMin: Math.min(...score).toExponential(4),
                    scoreMax: Math.max(...score).toExponential(4),
                    scoreSum: score.reduce((a, b) => a + b, 0).toExponential(4),
                    scoreSample: score.slice(0, 5).map(x => x.toExponential(4))
                });

                // Apply staggered score
                const stagScore = staggeredScore(score, deltaSigma, vocabSize);

                logStats('Position 0 Staggered Scores', {
                    stagScoreMin: Math.min(...stagScore).toExponential(4),
                    stagScoreMax: Math.max(...stagScore).toExponential(4),
                    stagScoreSum: stagScore.reduce((a, b) => a + b, 0).toExponential(4),
                    stagScoreSample: stagScore.slice(0, 5).map(x => x.toExponential(4))
                });

                // Get transition probabilities
                const trans = computeTransition(currentIdx, deltaSigma, vocabSize);

                logStats('Position 0 Transition', {
                    transMin: Math.min(...trans).toFixed(6),
                    transMax: Math.max(...trans).toFixed(6),
                    transSum: trans.reduce((a, b) => a + b, 0).toFixed(6),
                    transCurrent: trans[currentIdx].toFixed(6),
                    transSample: trans.slice(0, 5).map(x => x.toFixed(6))
                });

                // Combine score and transition
                const probs = stagScore.map((s, i) => s * trans[i]);

                logStats('Position 0 Final Probs', {
                    probMin: Math.min(...probs).toExponential(4),
                    probMax: Math.max(...probs).toExponential(4),
                    probSum: probs.reduce((a, b) => a + b, 0).toExponential(4),
                    probSample: probs.slice(0, 5).map(x => x.toExponential(4))
                });

                // Sample all positions
                log('Sampling new sequence...', 'debug');
                const newSequence = [];
                let changedCount = 0;
                for (let pos = 0; pos < currentSequence.length; pos++) {
                    const currentIdx = currentSequence[pos];
                    const score = scores[pos];
                    const stagScore = staggeredScore(score, deltaSigma, vocabSize);
                    const trans = computeTransition(currentIdx, deltaSigma, vocabSize);
                    const probs = stagScore.map((s, i) => s * trans[i]);
                    const newIdx = sampleCategorical(probs);
                    newSequence[pos] = newIdx;
                    if (newIdx !== currentIdx) changedCount++;
                }

                currentSequence = newSequence;
                currentStep++;

                const changePercent = (100 * changedCount / newSequence.length).toFixed(1);
                log(`Tokens changed: ${changedCount}/${newSequence.length} (${changePercent}%)`, 'success');

                // Show new text
                const newText = currentSequence.map(idx => vocab.itos[idx.toString()]).join('');
                document.getElementById('textPreview').textContent = newText;
                document.getElementById('currentStepDisplay').textContent = currentStep;

                log(`New text (first 100 chars): ${newText.substring(0, 100)}`, 'info');

                log('‚úÖ Denoising step completed successfully', 'success');

            } catch (error) {
                log(`‚ùå Error in denoising step: ${error.message}`, 'error');
                console.error('Full error:', error);
            }
        }

        // Run full generation
        async function runFullGeneration() {
            try {
                log('=== RUNNING FULL GENERATION ===', 'info');

                // Reset
                currentSequence = [];
                currentStep = 0;
                document.getElementById('currentStepDisplay').textContent = '0';

                // Initialize sequence
                const seqLen = metadata.block_size;
                const vocabSize = metadata.vocab_size;
                for (let i = 0; i < seqLen; i++) {
                    currentSequence.push(rng.randint(0, vocabSize));
                }

                log(`Starting with random sequence of length ${seqLen}`, 'info');

                // Run all steps
                const totalSteps = config.steps;
                for (let step = 0; step < totalSteps; step++) {
                    await testDenoisingStep();

                    // Update every 10 steps
                    if (step % 10 === 0) {
                        log(`Progress: ${step}/${totalSteps} steps completed`, 'info');
                    }

                    // Small delay to prevent UI freeze
                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                log('‚úÖ Full generation completed!', 'success');
                const finalText = currentSequence.map(idx => vocab.itos[idx.toString()]).join('');
                log(`Final text length: ${finalText.length} characters`, 'info');

            } catch (error) {
                log(`‚ùå Error in full generation: ${error.message}`, 'error');
                console.error('Full error:', error);
            }
        }

        // Initialize
        log('Debug tool ready. Load a model to begin.', 'info');
    </script>
</body>
</html>
